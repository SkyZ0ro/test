# Очередной CrackMe или Как я мучался с Ghidra. Мануал для новичков
**Коротко о себе:** я не гуру реверса, я не какой-нибудь профи с 20 летним стажем, я такой же обычный человек как и вы, я тоже запинался и не понимал как вы некоторое время назад. Я нахожусь на Linux Mint Cinnamon, поэтому это руководство подойдет для любого Linux дистрибутива. Можно попытаться сделать то же самое на Windows! *Ghidra кроссплатформенна, так что пользователи Windows смогут повторить все шаги практически один в один*  
  
*Если вы профессионал, вам всё равно может быть полезно освежить знания :-)*

**Боль новичка в реверсе:** это конечно же инструменты, разные на самом деле от текстовых редакторов до продвинутых декомпиляторов, дебаггеров и тому подобное, например: IDA бесплатная и платная версия, Ghidra, x64dbg, и другие. Согласитесь, инструменты хорошие но в них довольно легко запутаться. Также нельзя исключать и нужные знания.

* **Как работает компьютер.** Необходимо знать базу, да... Например материалы на YouTube или книги, я читаю книги от Андрея Столярова, хороший материал могу смело рекомендовать.
* **Математика.** Да, математика нужна, к счастью всю теорию и тригонометрию учить не нужно, достаточно знать базовые операции, комбинаторику и системы счисления (bin, dec, hex)
* **Логика.** Не азбуку, а компьютерную логику: AND, OR, XOR, NOT будет вполне достаточно.
* **Ассемблер x86-64.** Нет, не весь ассемблер, мне самому доводилось учить NASM упаси Господи... Достаточно для начала знать базовые ассемблерные мнемоники: MOV, ADD, SUB, CMP, JMP (и его разновидности), LEA, RET, CALL/EXTERN и TEST. Это учится быстро и есть много ресурсов извне, тот же YouTube ребят. А также регистры: RAX, RSI/RDI, RBX, RCX, RDX, RSP, RBP и прочие.
* **C/C++.** Да, кодить тоже нужно уметь. Но не волнуйтесь, не огромные проекты, а достаточно знать базу и синтаксис для начала. Ну или кодить пет-проект, например игрушку какую-нибудь с `ncurses` , я сам так делаю, помогает освежать знания языка.

**Цель этого мануала:** Не научить как хакать любые программы подряд, во-первых это *незаконно*, во-вторых это чисто физически невозможно. Но не отчаивайтесь! Цель же, это разобраться в инструментах, куда смотреть, как, что, зачем, почему и когда. поэтому он и называется "для новичков".

---

### Подготовка

Я использую Ghidra. Это один из мощных инструментов для реверсинга, с открытым исходным кодом, от... АНБ:-) И в этом мануале будет разбор именно с Ghidra. Если у вас IDA, по сути всё что будет ниже будет применимо и к ней, но я не в курсе об этом.

![Логотип](https://habrastorage.org/r/w1560/getpro/habr/upload_files/0de/314/1c5/0de3141c567d10af7e57c03f2881512b.PNG "Логотип")

Логотип

Инструмент на самом деле мощный, но сложноватый для новичков. Но не суть. Давайте же его установим! Для этого необходимо перейти на сайт <https://ghidralite.com/>, нажать сразу на Download now. Нас перекинет на Github releases, выбираем .zip скачиваем, распаковываем а дальше думаю понятно и без меня будет. Как только распаковали не спешим заходить туда. Ghidra был написан на Java поэтому нам еще нужен JDK:

```
sudo apt install openjdk-21-jdk
```

*Примечание: тут команда зависит от того какой у вам пакетный менеджер, на Mint это apt. У вас может быть другой, поэтому стоит это учитывать.*

Всё! заходим в папку с Ghidra, и вводим:

```
./GhidraRun
```

Спустя время оно должно загрузиться в саму программу. Нажимаем много раз далее если просит, всё подтверждаем. Поздравляю, мы в Гидре! Каждый раз при запуске оно будет показывать tips (подсказки) их не стоит убирать, лучше почитать, это действительно полезно!

Теперь вопрос: И где реверсинг? Не спешите так сильно, успеем. Нужно создать проект. Нажимаем File -> New Project -> (Тут выбор, Shared или Non-Shared. выбираем второе так как мы работаем одни, локально) -> Путь к директории оставим по умолчанию, и имя проекта, тут уже кто во что горазд. Поздравляю у нас есть новый проект. Дальше что?

Дальше проще. Нужен бинарник! Или проще .exe, то бишь исполняемый файл. Для теста мы создадим helloWorld.c, скомпилируем на gcc и дальше виднее:

```cpp
#include <stdio.h>

int main() {
  printf("Hello, World!\n");
  return 0;
}
```

Компилируем:

```bash
gcc helloWorld.c -o Hello
```

"-o Hello" означает что исполняемый файл будет под этим именем, а не по умолчанию "a.out" , запускаем и убеждаемся что работает.

Перед началом чудес, немного о Crackmes.one: Этот сайт специально создан для таких как я, ты, реверс-инжинеров. На этом сайте можно найти много разных задач, которые стоит решать, решать и решать! Вот ссылка <https://crackmes.one/search>. Желательно конечно на сайте зарегестрироваться, чтобы уметь оставлять комментарии и давать оценку сложности той или иной задачи. На сайте можно найти тучу разных задач, от самых сложных до самых "Изичных", Задачи на Unix/Linux и Windows и не только, задачи от разных авторов, а также возможность посмотреть решение задачи, если вдруг вы сдались и не смогли крякнуть бинарник самостоятельно.

---

**Первый запуск**

О! Мы начинаем подходить к самому главному! Самому реверсингу! В начале, помните Hello бинарник? Давайте закинем его в Ghidra и посмотрим какие черти в нем водятся:   
  
File -> Import File -> (Найдите наш Hello) -> OK (ничего не трогаем) -> Появится окно с первой информацией, ее можно почитать, можно пропустить.   
  
Всё, файл в проекте осталось открыть инструментом. В поле Tool Chest есть 4 инструмента (Если Гидра версии 11.4.2 и выше), в будущем мы будем ковыряться в отладчике (Debugger), но сейчас нам нужен только Code Browser.

![Интерфейс](https://habrastorage.org/r/w1560/getpro/habr/upload_files/04a/a01/5de/04aa015dea3eeb8a4bb049f179eba2fa.png "Интерфейс")

Интерфейс

Это Интерфейс. У вас может быть больше окон, но бояться нечего. Я сам тоже в начале жестко ошалел от этого, даже если пусто.

* Symbol Tree - Внутренности программы разделенные на отдельные пункты
* Data Type Manager - Говорит какие типы данных есть в программе
* Listing - Главное окно. Здесь будет код на языке Ассемблера!
* Decompile - Это попытка восстановить исходник на язык Си. Код будет техническим, то есть не сильно понятным, так как декомпилятор переводит прямые байты и адреса в переменные, циклы, и получается у нее это очень умело! Просто не очень понятно. Но главное, это окно может облегчить вид, построить примерную логику кода.
* Выше панель кнопок. Целое изобилие правда? Лучше пока не трогать их, они нам не нужны на данный момент.

Откроем наш Hello? File -> Open -> Hello -> YES -> (Здесь будет окно Analysis Options, тут тоже ничего не трогаем, просто жмем Analyze, Ghidra сама проанализирует бинарник и попытается ее восстановить). Немного ждем и вуаля!

![Листинг окно](https://habrastorage.org/r/w1560/getpro/habr/upload_files/fc4/f3e/46b/fc4f3e46b5bcb40e4116aff3de83f9c1.png "Листинг окно")

Листинг окно

Выглядит страшно, но тут нечего бояться. По сути нам нужна только точка входа а именно функция main, на картинке она обозначена розовым.   
  
**Что здесь происходит?**  
  
Всё просто:

1. `LEA RAX, [s_Hello,_World!_00102004]` помещаем нашу строку "Hello, World!" в регистр RAX по адресу.
2. Дальше `MOV RDI=>s_Hello,_World!_00102004,RAX` пихаем в RDI из RAX
3. `CALL <EXTERNAL>::puts` зовем функцию печати
4. Дальше просто Return 0. EAX 0x0, это обнуляется стек, а RET завершает функцию main.

**А что в Decompile?**   
  
В Decompile как раз таки все выглядит легче. Нажмите курсором на main и справа высветится попытка декомпилятора восстановить исходник на C.

![Окно декомпилированного кода](https://habrastorage.org/r/w1560/getpro/habr/upload_files/36f/412/83b/36f41283b5b40c2710b583420c96fd7c.png "Окно декомпилированного кода")

Окно декомпилированного кода

Здесь всё выглядит гораздо легче!

1. main это точка входа
2. puts это тоже самое что и printf, думаю английский знаем.
3. return 0; ну тут понятно.

   Здесь можно понять, что функция main с помощью puts пихает нам в глаза нашу строку :)  
     
   Тут же кстати можно заметить что undefined8 это тип данных, 8 байт это qword, проще говоря long или long long неважно, важно знать что это число, как и int.

**Другие окна**

![Symbol Tree Window](https://habrastorage.org/r/w1560/getpro/habr/upload_files/be4/417/5db/be44175db7382d46f599645d9d0931e0.png "Symbol Tree Window")

Symbol Tree Window

Это иерархическая структура всех символов. Проще говоря, оно показывает что в программе есть всякие функции, переменные, метки, классы. Для простых задач нам может понадобится пока что Imports и почти всегда Functions. Их можно раскрыть и посмотреть что там да как.   
  
Помните `#include <stdio.h>`? Во вкладке `EXTERNAL` можно найти "puts", то есть "printf", а значит программа использует библиотеку `stdio.h` - ввод\вывод. Ну или если вы прошаренный, увидеть`libc.so.6` это и есть `<stdio.h>`

---

**Всё ещё интересно? Тогда идем дальше! Зайдем на crackmes.one и выберем задачу!**

Мне приметилась вот такая задачка, кстати вот ссылка на нее: <https://crackmes.one/crackme/6963af82143c47935bdea9ab>

![Изображение задания с crackmes.one](https://habrastorage.org/r/w1560/getpro/habr/upload_files/428/c55/688/428c5568872ca87cb9f0a94b828b148b.png "Изображение задания с crackmes.one")

Изображение задания с crackmes.one

Задача относительно легкая, сейчас посмотрим что в ней, и расскажу как я ее крякал:

Первое это первый запуск самого исполняемого файла, оно выводит вот такое окошко с просьбой ввести лицензионный ключ (проще говоря пароль), причем оформлено всё отлично, в отдельном окошке а не в терминале :) Видно, постарался разработчик.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/358/a60/cd5/358a60cd55619967fef5104614ac6d5c.png)

Введём всякую белиберду, мало ли, прокатит¯\\_(ツ)\_/¯

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f3f/69f/ace/f3f69face5d33e093cfa9c06e1f0a98e.png)

М-да... Чего и стоило ожидать. Говорит "no cheating", но мы люди принципиальные, нас ничем не остановишь! Открываем данный файл в Ghidra!

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/742/64b/f1c/74264bf1cb42454eb26fe63e172ab5d1.png)

И это еще только половина! Не бойтесь, тут нет ничего страшного. Здесь на Си, написан код самого окна. По приставе "gtk" можно понять что в коде изначально был заголовочный файл `<gtk/gtk.h>` нужен он просто для графического интерфейса в Си, ничего необычного. Тут сложно что-то увидеть, поэтому поищем что-нибудь в Symbol Tree.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/f7a/ae6/4bd/f7aae64bd1c7df42d152409b1ad85eff.png)

Заходим в Functions и смотрим... Нам нужны main и valid, остальное мусор (*Под мусор я имею ввиду это код который сделал gcc и нужен он только для нужд процессора а не нам, его мы не трогаем*). Видим main и стороннюю функцию valid. Посмотрим что в ней?

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/5d1/632/71f/5d163271fad29a3dbdf867b5973a5393.png)

Ага! Здесь находится `iVarl`, это переменная которая обычно идет в связке с `strcmp`, по крайней мере я всегда видел ее рядом. `Strcmp` это функция сравнения строк из стандартной библиотеки `<string.h>` , если строки одинаковы значит iVarl = 0. Для удобства можно переименовать эту переменную в "IsValid" для меня это удобно. (Переименовать можно если навестить курсором на это слово, нажать ПКМ, найти "Rename Variable" и переименовать. Не перепутайте с Retype! :-)  
  
В любом случае, нам важно что именно оно сравнивает, это параметр 1, скорее всего это наш User ввод, то что мы будем вводить, и какой-то "UH", посмотрим что в ней! Нажмем на нее два раза и...

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/d84/df0/475/d84df047528c24074dbdcdcdb82d75d1.png)

Оно хранит адрес... Хм... ну давайте посмотрим что хранится в памяти по этому адресу? Кликнем на адрес дважды. На сторонние справа словечки типа "XREF[2]:" можно не обращать внимания, мы не за ними пришли.

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/a18/eac/1b3/a18eac1b36fc7c3e436dd70169604864.png)

Ага! Вот он наш лицензионный ключ! Ну или пароль, как угодно. Видно что это ds, значит это string, строка. Давайте попробуем его? Скопируем и вставим в программу...

![](https://habrastorage.org/r/w1560/getpro/habr/upload_files/00f/f7f/78b/00ff7f78bb7c9411ede1ee147efcf8c4.png)

**Бинго!** Пароль подошел, официально мы смогли "Крякнуть" crackme для обучения!

Есть и другие методы для обнаружения пароля, более простые:

```bash
strings исполняемый_файл // важно быть в той директории где находится сам исполняемый файл!
```

Эта команда в терминале покажет нам все строки которые есть в программе. Если чуть-чуть покопаться и методом проб и ошибок попыхтеть, можно найти наш пароль AEXORRBSHA36325S33 среди кучи всякого хлама.   
  
Метод хоть и рабочий но не всегда эффективный, в более сложных задачах такое уже не прокатит.   
  
Я показал этот метод в конце, чтобы развеять вам иллюзию "Туда сюда, реверс-инжинер", нет ребят, в это надо прям въезжать, чтобы вы поняли основной метод, а уже потом второстепенные. Впрочем, по чуть-чуть, по чуть-чуть, каждый день.

---

### Ну что ж? Выводы!

Что мы поняли сегодня? Мы поняли **что** именно нужно изучать для реверсинга, базу и основы Ghidra, и смогли крякнуть crackme вместе!

На самом деле это было действительно легко, и если включить логику, у вас тоже должно получиться! Попробуйте сами, если ошибетесь, практика — мать учения! Или как там правильно... Не суть.  
  
Напоминаю вам ещё раз дорогие читатели! Реверсинг — дело серьезное, если добавить в этот котёл хоть каплю злого умысла, ничем хорошим это не закончится **только** для вас.

Скоро будут доступны и другие статьи про реверс‑инжиниринг от меня, следите, скоро новые анонсы! Удачи всем, и хорошего кряка!